# 购物车组件的动态展示

## 添加购物车成功页面
  1. 配置跳转路由, 点击跳转
      - ```js
           {
               path:"/shopcart",
               component:ShopCart,
           },
           @click="$router.push('/shopcart')"
       ```
  2. 跳转路由时携带数据
    - params     刷新数据还在
    - query    刷新数据还在
    - vuex: 在跳转路由前先将数据保存到state中  问题: 刷新就会丢失
    - 纯浏览器端存储: sessionStorage与localStorage 
    
    * detail: 详情页   
      * 点击添加到购物车:携带数据 通过sessionStorage.setItem(key,value)设置 => 跳转到添加成功的界面AddCartSuccess
    * AddCartSuccess: 添加成功的界面   通过sessionStorage.getItem(key)获取数据 就可以得到添加的商品属性: 数量,图片,标题等等...
    * AddCartSuccess: 查看商品详情 需跳转到detail页面 并携带商品的id  `router-link :to="{name:'detail', params:{skuId:skuInfo.id}}"`    `router-link :to="`/detail/${skuInfo.id}`"`

## sessionStorage与localStorage的使用和区别
   - 共同点:
      - 都是只保存在浏览器端
      - 存储的是文本字符串(如果指定的是对象会自动转换为字符串保存), 
      - 如果要保存对象/数组, 应该转换为JSON字符串后保存
      - 语法基本一样:
        - sessionStorage.setItem(key, value)/getItem(key)/removeItem(key)
        - localStorage.setItem(key, value)/getItem(key)/removeItem(key)
   - 不同点:
        - sessionStorage: 保存在浏览器运行的内存中, 刷新浏览器数据还在, 关闭浏览器会自动清除
        - localStorage: 保存在浏览器管理的本地文本中, 无论刷新还关闭浏览器还会存在, 不自动清除

## 购物车页面的动态展示
   1. api  配置路由  
     - ```js
            // 购物车  post请求   /api/cart/addToCart/{ skuID }/{ skuNum }
            export const reqAddToCart = (skuId, skuNum) => ajax.post(`/cart/addToCart/${skuId}/${skuNum}`)

            // 获取购物车列表    /api/cart/cartList   GET
            export const reqCartList = () => ajax('cart/cartList')

            // 切换商品选中状态    /api/cart/checkCart/{skuID}/{isChecked}  GET 
            // isChecked   0: 取消选中状态   1: 选中  
            export const reqCheckCartItem = (skuId, isChecked) => ajax(`/cart/checkCart/${skuId}/${isChecked}`)

            // 删除购物车商品   /api/cart/deleteCart/{skuId}    DELETE
            export const reqDeleteItem = (skuId) => ajax.delete(`/cart/deleteCart/${skuId}`)
        ```
   2. vuex  
        - ```js
            import {reqCartList, reqCheckCartItem, reqAddToCart} from '@/api'

            export default  {
                state={},
                mutations={},
                actions={},
                getters={}
            }
        ```

   3. component  组件中 读取 分发异步action
        - ```js
            import {mapState, mapGetters} from "vuex"
            computed:{
                ...mapState({
                    cartList: state => state.shopCart.cartList
                }),
                ...mapGetters(['totalCount', 'totalPrice']),
            },
            mounted(){
                this.$store.dispatch("getCartList")
            },
            
        ```
### 未登录状态随机生成用户id   userTempid        
通过UUID库来创建
- userTempId的作用:
    - 在用户未登陆前的身份标识, 用于识别不同的浏览器访问
- userTempId的特点
    - 它是一个随机唯一的字符串值: 多个客户端之间不相同, 同一个客户端如果产生多次也不同     UUID
    - 由浏览器端创建, 每次请求都携带给服务器端
    - 一旦产生, 尽量不删除或修改, 可以一直使用
- userTempId的创建与保存
    - 使用UUID库来创建: uuidv4()
    - 保存在哪?: 
        - localStorage   ===> 关闭浏览器还存在
        - vuex的state中: 从localStorage中读取uuid值保存到state中  ==> 减少从localStorage读取的次数
- userTempId使用
    - 每次请求都携带上userTempId: 使用axios的请求拦截器

### 改变商品的勾选状态以及与全选框的勾选状态
   - api
   - vuex
   - component
- 利用计算属性的getter和setter属性
  - 点击单个选框  控制全选框的状态 : 利用getter
  - 点击全选框  控制单个选框的状态 : 利用setter
    - 利用Promise.all() 控制多个异步操作的promise与管理
 ```js
    isAllChecked:{
        get(){
            // 判断
            // return this.cartList.find(item => item.isChecked!==1)===undefined
            // return this.cartList.filter(item => item.isChecked===1).length===this.cartList.length
            // return !this.cartList.some(item => item.isChecked!==1)
            return this.cartList.every(item => item.isChecked===1)
        },
        // 监视当前勾选状态的改变  利用异步action
        async set(value){
          try{
              // 分发
            await this.$store.dispatch("checkAllCartItems",value)
            // 成功之后再次获取数据
            this.$store.dispatch('getCartList')
          }catch(error){  //请求失败
            alert(error.message)
          }
        }

—————————————————————————————————————————  我是分割线  ————————————————————————————————————————————————

        async checkAllCartItems({commit,state,dispatch,getters}, checked){
            const isChecked = checked ? 1 : 0
            const promises = []
            // 遍历cartList, 看是否都选中了
            state.cartList.forEach(item => {
                // 判断 如果当前选项处于选中状态或是为选中状态,也就是说大年状态和传入的状态一致,就return  即不发送请求改变状态
                if(item.ischecked === isChecked) return
                // 分发单个选中的状态
                const promise = dispatch('checkCartItem', {skuId: item.skuId, isChecked})
                // 将每个异步action的promise添加到promises数组中
                promises.push(promise)
            })

            // 利用Promise.all()来实现对多个异步操作的promise的管理
            return Promise.all(promises)
        },
 ```


