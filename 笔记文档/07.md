# Detail组件的动态显示

## 导航路径区域数据的动态展示
- 获取数据 动态展示
- 通过vuex的getters属性解决 detailInfo.categoryView为undefined的问题

## 错误的解决: "TypeError: Cannot read property 'category1Name' of undefined"
  - TypeError: 类型错误
  - Cannot read property 'xxx' of undefined: xxx前面的值为undefined
  - 例: detailInfo.categoryView.category1Name => detailInfo.categoryView 就是undefined
  - 原因: detailInfo的初始值为{}, detailInfo.categoryView 则为undefined
  - 解决:
    - 1. 通过v-if控制, 在detailInfo.categoryView为undefined时,不解析此模块(但是不能使用v-show,因为v-show是通过标签的属性display为none来隐藏的,只是不显示,不是不解析)
    - 2. 利用vuex的getters来处理(推荐)
        ```js
            const getters = {
                categoryView(state){
                const categoryView = state.detailInfo.categoryView
                    return categoryView || {} // return CategoryView ? categoryView : {}
                },
            }
        ```

## imageList, Zoom组件的动态显示
1. 小图列表的动态展示
    - 轮播: swiper 在列表显示之后创建   `this.$nextTick(() => {new Swiper("swiper",{配置对象})})`
    - 选中: 点击变换active的位置  `currentIndex===index` 
    - 点击小图,中图大图也对应变化  通过给Zoom组件强制绑定当前点击的图片的地址改变
    - ```js
        <Zoom v-if="skuImageList.length>0"
            :bigUrl="skuImageList[currentIndex].imgUrl"
            :imgUrl="skuImageList[currentIndex].imgUrl"  
        />
      ```
2. 遮罩和大图的显示
    - 给遮罩绑定鼠标的移动事件  通过计算鼠标箭头与遮罩的距离(鼠标箭头在中间),鼠标箭头距大div的距离得出left和top值,并赋值给遮罩的样式,以及大图的样式(-2left,-2top)来控制遮罩的位置及大图的显示位置
    - ```js
        // 初始化left top 
        let left = 0
        let top = 0
        // 取出相关的数据 
        const {offsetX, offsetY} = event  
        // 鼠标箭头距事件div的距离   鼠标箭头距mask遮罩div的距离
        const maskWidth =  this.$refs.mask.clientWidth
        left = offsetX - maskWidth/2
        // 临界点  [0, maskWidth]
        if(left < 0){
          left = 0
        }else if(left > maskWidth){
          left = maskWidth
        }
        top = offsetY - maskWidth/2
        // 临界点  [0, maskWidth]
        if(top < 0){
          top = 0
        }else if(top > maskWidth){
          top = maskWidth
        }
        // 获取目标元素   设置目标元素的样式
        // 遮罩
        const maskDiv = this.$refs.mask
        maskDiv.style.left = left + "px"
        maskDiv.style.top = top + "px"
        // 大图
        const bigDiv = this.$refs.big
        bigDiv.style.left = -2 * left + "px"
        bigDiv.style.top = -2 * top + "px"
      ```
## 购物车

### 点击添加购物车
在点击添加的过程中,需分发异步action, => 要通过回调函数callback来通知组件是否成功  或通过async await函数
1. 通过回调函数传参是否有值来判断成功或失败  `dispatch('addToCart', {skuId, skuNum, callback: this.callback})` 
    - action: 请求成功或失败后, 调用callback(errorMsg值) // 向组件传递需要显示的errorMsg
    - component: 在callback中, 根据errorMsg参数是否有值来做相应处理
```js
    async addToCart({commit}, {skuId, skuNum,callback}){ 
        // 异步接收传入的参数数据
        const result = await reqAddToCart(skuId, skuNum)
        if(result.code === 200){
            console.log("成功")
            callback()
        }else{
            console.log("失败")
            callback("失败")
        }
    }
/* ——————————————————————   我是分割线   —————————————————————— */
    addToCart(){
        // 获取skuId  skuNum
        const skuId = this.$route.params.skuId
        const skuNum = this.skuNum
        // // 1.   直接分发异步action   但是此时在分发之前就执行当前组件   要通过callback回调函数来操作
        this.$store.dispatch("addToCart",{skuId, skuNum, callback: this.callback})
    }
```

2. 利用dispatch的promise返回值
    - async await函数的返回值是promise,并且promise的结果由函数的结果决定
    - dispatch()的返回值是promise对象,并且就是async await函数返回的promise
        - 通过dispatch()的promise返回值 是否有数据 来判断是成功还是失败
        - 利用try{}catch(){}捕获错误   抛出一个error状态的promise  throw new Error()
```js
    // async addToCart({commit}, {skuId, skuNum,callback}){ 
    //     // 异步接收传入的参数数据
    //     const result = await reqAddToCart(skuId, skuNum)
    //     if(result.code === 200){
    //         return ""
    //     }else{
    //         return "失败"
    //     }
    // },

    async addToCart({commit}, {skuId, skuNum,callback}){ 
        // 异步接收传入的参数数据
        const result = await reqAddToCart(skuId, skuNum)
        if(result.code === 200){
            return ""
        }else{
            throw new Error("失败")
        }
    }

/* ——————————————————————   我是分割线   —————————————————————— */

    async addToCart(){
        // 获取skuId  skuNum
        const skuId = this.$route.params.skuId
        const skuNum = this.skuNum
        // 2.通过async await函数返回的promise操作     
        // 利用dispatch()的promise返回值  此返回值就是async函数返回的promise
          // const errorMsg = await this.$store.dispatch("addToCart",{skuId, skuNum})
          // if(errorMsg){  // 有值则失败
          //   alert(errorMsg)
          // }else{
          //   alert("添加成功")
          // }
        // 通过try catch 捕获错误
        try{
           await this.$store.dispatch("addToCart",{skuId, skuNum})
           alert("添加成功")
        }catch(error){
          alert(error.message)
        }
      },
```
 