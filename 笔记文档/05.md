## 获取动态数据

### 创建vuex的js代码并暴露
  - 创建: `const state = {}, actions = {}, mutations = {}, getters = {},`
    - 初始化: `state = {}`
    - commit: `actions = {}`
    - state.xxx: `mutations = {}` mutations里面的方法必须大写
    - 在需使用的组件中的mounted中分发: dispatch  
    - 在需使用的组件中 `...mapState({xxx: state => state.x.xxx})`
  - 暴露: `export default {state, actions, mutations, getters}`
  - 创建模块: `export default = new Vuex.Store({modules:{  xxx }})`
  - ajax请求: `export const xxx = () => ajax({url:"",methods:""}, data:"")`

###  query参数 params参数  根据分类和关键字进行搜索
  - query参数: path或name都可以进行组合使用    
  - params参数: 不能用path和params结合, 只能用name和params结合
  - params参数可传可不传
    - path: '/search/:keyword?'
    - (用props将params参数和query参数映射成属性传入路由组件)
  - vue中路由传参query和params的区别
    - query相当于发送了一次get请求  请求参数会显示在浏览器的地址栏中
    - params相当于发送了一次post请求  请求参数不会显示  并且刷新页面之后参数会消失

### 同一个路由之间跳转时,此路由的组件对象不会重新创建,不会重新执行初始化生命周期回调
- 通过`watch:{$route(){}}`监视  => 监视$route的变化(A路由 => A路由, $router是重新产生)

### 当执行删除条件时,删除指定的数据,但是并没有修改路由参数数据
- `this.$router.replace(this.$route.path)`  $route.path不带query参数, 但带params参数(如果有)
- `this.$router.replace({name: 'search', query: this.$route.query})`  重新跳转到当前路由, 不再携带params参数, 只携带原本的query参数

### 兄弟组件间通信  全局事件总线
- `Vue.prototype.$globalEventBus = new Vue({})`
```js
new Vue({
  beforeCreate(){
    Vue.prototype.$globalEventBus = this
  },
  render: h => h(App),
  router,
  store,
}).$mount("#app")
```
### 阻止默认行为: (.prevent)   阻止冒泡: (.stop)

