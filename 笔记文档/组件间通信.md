# 组件间通信

## 组件间多种通信方式:
1. 组件间通信最基本方式: props
2. 组件间通信高级1: vue自定义事件与事件总线
3. 组件间通信高级2: v-model深入
4. 组件间通信高级3: 属性修饰符sync
5. 组件间通信高级4: $attrs与$listeners
6. 组件间通信高级5: $children与$parent
7. 组件间通信高级6: 作用域插槽slot-scope
8. 组件间通信高级7: vuex

## 一、组件间通信最基本方式: props  (父子间通信)
  实现父子间通信的最基本的方式, 也是用的最多的方式
   - 父 => 子  传递的是非函数类型的属性   通过强制绑定  v-bind  :  传递 
   - 子 => 父  传递的是函数类型的属性    通过函数的传参传递数据

## 二、vue自定义事件与事件总线  
1. 事件总线  (祖孙/兄弟)
    vm实例对象是组件对象的原型对象,组件对象可以直接访问Vue原型对象上的方法,实现任意组件间通信
    Vue原型对象上有3个事件处理的方法,$on(), $emit(), $off()
   - 在入口js文件中,将vm作为全局事件总线的对象
     ```js
       beforeCreate(){ 
           Vue.prototype.$globalEventBus = this 
       }
     ```
   - 分发事件: this.$globalEventBus.$emit('xxx', data)
   - 处理事件: this.$globalEventBus.$on('xxx', data)

2. 自定义事件 (子 -> 父)
    1. Vue的自定义事件, 用来实现子组件想父组件通信(功能相当于props) (子 -> 父)
        - 绑定vue的自定义事件,监听,只能在组件标签上绑定
        - 事件名是任意的,可以与原生DOM事件名相同
          - 只有当执行$emit('xxx', data) 时分发自定义事件, 才会触发自定义事件监听函数调用
          - $event: 分发自定义事件时指定的data数据, $event可以是任意类型,甚至可以没有

    2. 原生DOM事件
        当用户操作对应的界面时,浏览器会自动创建并封闭包含相关数据的事件对象, 分发对应的事件, 从而触发事件监听回调函数
        - 原生DOM的事件监听
          - 在HTML标签上绑定事件名
          - 在组件标签上绑定DOM事件名, 事件绑定在组件的跟标签上
        - 事件对象event的本质是'事件数据对象'
        - $event就是浏览器内部创建的event对象,即默认传递给事件监听回调函数的参数
        - event对象内的数据属性: target 、offsetX 、offsetY 、keyCode......
  
## 三、v-model
    页面和数据 双向数据绑定
   - 原生事件的v-model: 原生的input事件监听 和 value的动态属性
     - `<input type="text" :value='name1' @input="name1=$event.target.value">`
   - 组件标签的v-model: 自定义input事件监听 和 value的动态属性
     - 子组件: 接收数据并分发事件 `  props: ['value']   <input type="text" :value='value' @input="$emit('input', $event.target.value)">`  
     - 父组件: `<CustomInput :value='name3' @input="name3=$event" /> `
   
   * v-model的作用
     * 实现原生标签的双向数据绑定 和 组件标签的双向数据绑定
     * 实现父子组件间上相数据 同步
     * 一般用于封装带表单项的复用性组件
     * 在element-ui中: Input/CheckBox/Radio/Select等表单项组件都封装了v-model

## 属性修饰符sync
绑定事件监听,通过接收子组件分发事件携带的最新数据来更新父组件的数据
   - `<Child :money.sync="money" />`
   - `<Child :money='money' @updateMoney='money=$event'/>  |  <button @click="$emit('updateMoney', money-100)">花钱</button>`

   * sync的作用
     * 实现父子组件间数据双向同步
     * 常用于封装更新父组件数据的复用性组件

   * sync与v-model的区别
     * v-model: 一般用于带表单项标签的组件
     * sync: 一般用于不带表单项标签的组件

   * 在element-ui中, Dialog就利用sync来实现组件的隐藏

## $attrs与$listeners
   - `$attrs`: 排除props声明, class, style的所有组件标签属性组成的对象
   - `$listeners`: 组件标签绑定的所有自定义事件监听的对象
   - `v-bind="$attrs"`: 能将所有父组件传递过的属性(不包括props)都传递给子组件
   - `v-on="$listeners"`: 能将所有父组件给我绑定的监听都绑定给子组件
   
   * `v-bind`的特别使用: `<div v-bind="{ id: someProp, 'other-attr': otherProp }"></div>`
   * `v-on`的特别使用: `<button v-on="{ mousedown: doThis, mouseup: doThat }"></button>` 
   * v-bind与$attrs配合使用, v-on与$listeners配合使用

* 使用
  * 在封装可复用组件时,从父组件中接收不定数量、名称的属性或事件监听
  * 在组件内部, 传递给它的子组件
  * 在element-ui中, Input使用了v-bind与$attrs来接收不定的属性传递给input

* 双击事件
   * `@dblclick="add2"` : 绑定是自定义事件监听, 而el-button内部并没处理(没有绑定对应的原生监听, 没有分发自定义事件)双击时, 不会有响应
   * `@dblclick.native="add2"` : 绑定的是原生的DOM事件监听, 最终是给组件的根标签`<a>`绑定的原生监听, 当双击a内部的`<button>`能响应, 因为事件有冒泡

## $children与$parent属性
  - $children: 所有直接子组件对象的数组, 利用它可以更新多个子组件的数据
  - $parent: 父组件对象, 更新父组件的数据
  - $refs: 包含所有有ref属性的标签对象或组件对象的容器对象

* $children与$parent属性的作用
  * 能方便得到子组件、后代组件、父组件、祖辈组件对象, 从而更新其data或调用其方法
  * 但官方建议不要大量使用, 优先使用props和event
  * 在一些UI组件库定义高复用组件时会使用$children和$parent, 如Carousel组件

- 多个组件有部分相同的js代码?
    - 利用vue的mixin技术实现
      - 创建mixin.js 在子组件中引入 并配置  ` import {cpMixin} from './mixins'    mixins: [cpMixin], `
    - 当多个组件的JS配置部分有一些相同重复的代码时
    - 本质: 实现Vue组件的JS代码复用, 简化编码的一种技术

## 作用域插槽slot-scope
    封装列表类组件
  - 使用情况: 父组件需要向子组件传递标签结构内容, 但决定父组件传递怎样标签结构的数据在子组件中
  - 子组件: `slot :row="item" :$index="index"> </slot>`  slot的属性会自动传递给父组件
  - 父组件: ```js
                <!-- <template slot-scope="scope"> -->
                                    <!-- 解构赋值 -->
                <template slot-scope="{row, $index}"> 
                    <span>{{$index+1}}</span> &nbsp;&nbsp;
                    <span :style="{color: $index%2===1 ? 'blue' : 'green'}" >{{row.text}}</span>
                </template>
            ```
  - element-ui中, Table组件中用到了slot-scope

## vuex
- Vuex是一个用于集中式管理多组件共享状态数据的工具
- Vuex应用的核心是store(仓库),包含应用中大部分的状态(state)
- Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
- 不能直接改变store中的状态.改变的唯一途径就是显式的提交(commit)mutation.

* 创建store:
  - ```js
        import Vue from 'vue'
        import Vuex from 'vuex'
        const store = new Vuex.Store({
            state: {
                count: 0
            },
            mutations: {
                increment (state) {
                state.count++
                }
            }
        })
    ```
* 获取状态数据  (store.state 来获取状态对象，以及通过 store.commit 方法触发状态变更)
  - ```js
        store.commit('increment')
        console.log(store.state.count) // -> 1
    ```
### 状态变化的过程  
通过dispatch Actions  -> commit  mutations -> 去改变state 

### 构成 (核心概念)
1. State
2. Getter
3. Mutation
4. Action
5. Module




