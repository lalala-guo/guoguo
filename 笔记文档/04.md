## 利用mock的接口实现动态的ListContainer与Floor组件

### 使用swiper实现静态页面轮播
- 下载  `npm i swiper -S`
- 引入  `import Swiper from "swiper"`     `import "swiper/css/swiper.css"`
- 使用 文档   https://www.swiper.com.cn/api/start/new.html
  - ```js
        new Swiper("swiper-container", {
            //  direction: 'horizontal', // 水平切换, 默认就是这个值
            //  direction: vertical ,   //  垂直切换
            loop: true, // 循环模式选项

            // 如果需要分页器
            pagination: {
                el: '.swiper-pagination',
            },

            // 如果需要前进后退按钮
            navigation: {
                nextEl: '.swiper-button-next',
                prevEl: '.swiper-button-prev',
            },
        })
    ```
### 一个swiper  多个效果冲突  解决   ref  refs  
  - `new Swiper ('.swiper-container')`, 类名选择器匹配了页面中所有的swiper界面, 都产生了效果
  - 使用ref技术: 通过`ref`标识`swiper`的根div, `new Swiper (this.$refs.swiper)`

### swiper动态页面轮播的bug : 直接在mounted内部创建swiper对象  没有轮播效果
  - swiper对象创建的太早  异步  swiper对象在列表数据显示之后才创建  
  - 通过定时器解决  但是不知道延迟时间
  - 通过watch 来监视 数据的变化  从而动态创建swiper对象   watch + $nextTick(() => {})
    - ```js
        watch:{
            floor(){
                this.$nextTick(() => {
                    this.initSwiper()
                })
            }
        },
      ```
### vue.nextTick()
  - nextTick()，是将回调函数延迟在下一次dom更新数据后调用，简单的理解是：当数据更新了，在dom中渲染后，自动执行该函数，
  - 文档: https://blog.csdn.net/zhouzuoluo/article/details/84752280
  - 例: Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中，原因是在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted钩子函数，因为该钩子函数执行时所有的DOM挂载已完成。

### 动态组件操作   
  - 分发异步`action: this.$strore.dispatch('getFloors')`
  - 从state中读取数据: `mapState({floors: state => state.home.floors})`
  - 在模板中显示数据
  - vuex: action =>先调用接口请求函数 ==> 成功后提交mutation ==>　mutation ==> 更新状态数据

### 查看动态数据   (输出打印  但是页面没有显示)
  - 利用Vue开发调试工具 ==> 组件中的数据(props/data/computed/vuex)
  - 利用vuex开发调试工具 ==> vuex管理的数据(state/getters)
  - 利用network ==> 查看请求(响应数据/url/method/params/query)

### 定义可复用的轮播组件
  - 抽取swiper 轮播 html 部分 js部分  创建轮播组件
  - 在入口文件中引入 并创建组件  例: `import Carousel from "./components/Carousel/Carousel.vue";    Vue.component("Carousel",Carousel);`
  - 在需要使用的地方 使用当前创建的组件  例: `<Carousel :carouselList="banners"/>` 
  - 读取`banners` 在组件中传给 `carouselList`  `...mapState({ banners: state => state.home.banners })      <Carousel :carouselList="banners"/>`

### 解决Floor组件的轮播bug
- ListContainer:
  - 默认 当数据是 空数组 [] 的时候, 初始显示时创建Carousel组件对象, 不会调用watch  也不会创建swiper对象 
  - 当数组里有数据时 [...], Carousel组件对象调用watch的回调 => 更新显示 => 会创建一个Swiper对象   
- Home中的`<Floor v-for="floor in floors" :key="floor.id" :floor="floor"/>`
  - Floors
    - 默认 空数组时 [] , Floor组件对象没有创建, 内部的Carousel组件对象也就没有创建
    - 当数组有数据时 [...] , 创建多个Floor组件对象, 内部就会创建Carousel组件对象 ==> 不会执行watch的回调
* 原因: 
    * 基础理解: 给组件标签传入的属性值是空数组/undefined, 组件对象会创建
        * 如果是通过v-for遍历一个空数组或undefined来产生多个标签, 组件对象不会创建
    * watch默认: 初始创建显示不会执行, 只有在数据变化后才会执行
        * 得到结果: 
            * banners对应的<Carousel>有更新显示 ==> 会调用watch的回调创建swiper对象 
            * floors所对应的所有<Carousel>都没有更新显示 ==> 不会调用watch的回调, 没有创建swiper对象

* 解决
  
  * mounted() + watch回调
    - mounted()中: 判断如果已经有数据了, 立即创建swiper对象
    - watch回调: 判断如果有数据, 延迟创建swiper对象
  
  * watch配置
    - `handler(){}`
    - `immediate: true`  表示在初始显示之前就会调用一次
    ```js
        watch: {
            carouselList: {
                handler(value){
                    if(value.length > 0){
                        this.$nextTick(() => {
                            this.initSwiper()
                        })
                    }
                },
                immediate: true,
            }
        },
    ```